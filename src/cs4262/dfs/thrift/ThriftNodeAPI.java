/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package cs4262.dfs.thrift;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
@Generated(value = "Autogenerated by Thrift Compiler (1.0.0-dev)", date = "2015-3-31")
public class ThriftNodeAPI {

  public interface Iface {

    public void join(String joiningHost, int joiningPort) throws org.apache.thrift.TException;

    public void leave(String leavingHost, int leavingPort) throws org.apache.thrift.TException;

    public void ser(int queryId, String queryingHost, int queryingPort, String fileName, int hopCount) throws org.apache.thrift.TException;

    public void serok(int queryId, String foundHost, int foundPort, List<String> matchingFiles, int hopCount) throws org.apache.thrift.TException;

  }

  public interface AsyncIface {

    public void join(String joiningHost, int joiningPort, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void leave(String leavingHost, int leavingPort, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void ser(int queryId, String queryingHost, int queryingPort, String fileName, int hopCount, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

    public void serok(int queryId, String foundHost, int foundPort, List<String> matchingFiles, int hopCount, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

  }

  public static class Client extends org.apache.thrift.TServiceClient implements Iface {
    public static class Factory implements org.apache.thrift.TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(org.apache.thrift.protocol.TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(org.apache.thrift.protocol.TProtocol prot)
    {
      super(prot, prot);
    }

    public Client(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot) {
      super(iprot, oprot);
    }

    public void join(String joiningHost, int joiningPort) throws org.apache.thrift.TException
    {
      send_join(joiningHost, joiningPort);
      recv_join();
    }

    public void send_join(String joiningHost, int joiningPort) throws org.apache.thrift.TException
    {
      join_args args = new join_args();
      args.setJoiningHost(joiningHost);
      args.setJoiningPort(joiningPort);
      sendBase("join", args);
    }

    public void recv_join() throws org.apache.thrift.TException
    {
      join_result result = new join_result();
      receiveBase(result, "join");
      return;
    }

    public void leave(String leavingHost, int leavingPort) throws org.apache.thrift.TException
    {
      send_leave(leavingHost, leavingPort);
      recv_leave();
    }

    public void send_leave(String leavingHost, int leavingPort) throws org.apache.thrift.TException
    {
      leave_args args = new leave_args();
      args.setLeavingHost(leavingHost);
      args.setLeavingPort(leavingPort);
      sendBase("leave", args);
    }

    public void recv_leave() throws org.apache.thrift.TException
    {
      leave_result result = new leave_result();
      receiveBase(result, "leave");
      return;
    }

    public void ser(int queryId, String queryingHost, int queryingPort, String fileName, int hopCount) throws org.apache.thrift.TException
    {
      send_ser(queryId, queryingHost, queryingPort, fileName, hopCount);
      recv_ser();
    }

    public void send_ser(int queryId, String queryingHost, int queryingPort, String fileName, int hopCount) throws org.apache.thrift.TException
    {
      ser_args args = new ser_args();
      args.setQueryId(queryId);
      args.setQueryingHost(queryingHost);
      args.setQueryingPort(queryingPort);
      args.setFileName(fileName);
      args.setHopCount(hopCount);
      sendBase("ser", args);
    }

    public void recv_ser() throws org.apache.thrift.TException
    {
      ser_result result = new ser_result();
      receiveBase(result, "ser");
      return;
    }

    public void serok(int queryId, String foundHost, int foundPort, List<String> matchingFiles, int hopCount) throws org.apache.thrift.TException
    {
      send_serok(queryId, foundHost, foundPort, matchingFiles, hopCount);
      recv_serok();
    }

    public void send_serok(int queryId, String foundHost, int foundPort, List<String> matchingFiles, int hopCount) throws org.apache.thrift.TException
    {
      serok_args args = new serok_args();
      args.setQueryId(queryId);
      args.setFoundHost(foundHost);
      args.setFoundPort(foundPort);
      args.setMatchingFiles(matchingFiles);
      args.setHopCount(hopCount);
      sendBase("serok", args);
    }

    public void recv_serok() throws org.apache.thrift.TException
    {
      serok_result result = new serok_result();
      receiveBase(result, "serok");
      return;
    }

  }
  public static class AsyncClient extends org.apache.thrift.async.TAsyncClient implements AsyncIface {
    public static class Factory implements org.apache.thrift.async.TAsyncClientFactory<AsyncClient> {
      private org.apache.thrift.async.TAsyncClientManager clientManager;
      private org.apache.thrift.protocol.TProtocolFactory protocolFactory;
      public Factory(org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.protocol.TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(org.apache.thrift.transport.TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.async.TAsyncClientManager clientManager, org.apache.thrift.transport.TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void join(String joiningHost, int joiningPort, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      join_call method_call = new join_call(joiningHost, joiningPort, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class join_call extends org.apache.thrift.async.TAsyncMethodCall {
      private String joiningHost;
      private int joiningPort;
      public join_call(String joiningHost, int joiningPort, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.joiningHost = joiningHost;
        this.joiningPort = joiningPort;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("join", org.apache.thrift.protocol.TMessageType.CALL, 0));
        join_args args = new join_args();
        args.setJoiningHost(joiningHost);
        args.setJoiningPort(joiningPort);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_join();
      }
    }

    public void leave(String leavingHost, int leavingPort, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      leave_call method_call = new leave_call(leavingHost, leavingPort, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class leave_call extends org.apache.thrift.async.TAsyncMethodCall {
      private String leavingHost;
      private int leavingPort;
      public leave_call(String leavingHost, int leavingPort, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.leavingHost = leavingHost;
        this.leavingPort = leavingPort;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("leave", org.apache.thrift.protocol.TMessageType.CALL, 0));
        leave_args args = new leave_args();
        args.setLeavingHost(leavingHost);
        args.setLeavingPort(leavingPort);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_leave();
      }
    }

    public void ser(int queryId, String queryingHost, int queryingPort, String fileName, int hopCount, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      ser_call method_call = new ser_call(queryId, queryingHost, queryingPort, fileName, hopCount, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class ser_call extends org.apache.thrift.async.TAsyncMethodCall {
      private int queryId;
      private String queryingHost;
      private int queryingPort;
      private String fileName;
      private int hopCount;
      public ser_call(int queryId, String queryingHost, int queryingPort, String fileName, int hopCount, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.queryId = queryId;
        this.queryingHost = queryingHost;
        this.queryingPort = queryingPort;
        this.fileName = fileName;
        this.hopCount = hopCount;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("ser", org.apache.thrift.protocol.TMessageType.CALL, 0));
        ser_args args = new ser_args();
        args.setQueryId(queryId);
        args.setQueryingHost(queryingHost);
        args.setQueryingPort(queryingPort);
        args.setFileName(fileName);
        args.setHopCount(hopCount);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_ser();
      }
    }

    public void serok(int queryId, String foundHost, int foundPort, List<String> matchingFiles, int hopCount, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException {
      checkReady();
      serok_call method_call = new serok_call(queryId, foundHost, foundPort, matchingFiles, hopCount, resultHandler, this, ___protocolFactory, ___transport);
      this.___currentMethod = method_call;
      ___manager.call(method_call);
    }

    public static class serok_call extends org.apache.thrift.async.TAsyncMethodCall {
      private int queryId;
      private String foundHost;
      private int foundPort;
      private List<String> matchingFiles;
      private int hopCount;
      public serok_call(int queryId, String foundHost, int foundPort, List<String> matchingFiles, int hopCount, org.apache.thrift.async.AsyncMethodCallback resultHandler, org.apache.thrift.async.TAsyncClient client, org.apache.thrift.protocol.TProtocolFactory protocolFactory, org.apache.thrift.transport.TNonblockingTransport transport) throws org.apache.thrift.TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.queryId = queryId;
        this.foundHost = foundHost;
        this.foundPort = foundPort;
        this.matchingFiles = matchingFiles;
        this.hopCount = hopCount;
      }

      public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException {
        prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("serok", org.apache.thrift.protocol.TMessageType.CALL, 0));
        serok_args args = new serok_args();
        args.setQueryId(queryId);
        args.setFoundHost(foundHost);
        args.setFoundPort(foundPort);
        args.setMatchingFiles(matchingFiles);
        args.setHopCount(hopCount);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws org.apache.thrift.TException {
        if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());
        org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_serok();
      }
    }

  }

  public static class Processor<I extends Iface> extends org.apache.thrift.TBaseProcessor<I> implements org.apache.thrift.TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(I iface) {
      super(iface, getProcessMap(new HashMap<String, org.apache.thrift.ProcessFunction<I, ? extends org.apache.thrift.TBase>>()));
    }

    protected Processor(I iface, Map<String,  org.apache.thrift.ProcessFunction<I, ? extends  org.apache.thrift.TBase>> processMap) {
      super(iface, getProcessMap(processMap));
    }

    private static <I extends Iface> Map<String,  org.apache.thrift.ProcessFunction<I, ? extends  org.apache.thrift.TBase>> getProcessMap(Map<String,  org.apache.thrift.ProcessFunction<I, ? extends  org.apache.thrift.TBase>> processMap) {
      processMap.put("join", new join());
      processMap.put("leave", new leave());
      processMap.put("ser", new ser());
      processMap.put("serok", new serok());
      return processMap;
    }

    public static class join<I extends Iface> extends org.apache.thrift.ProcessFunction<I, join_args> {
      public join() {
        super("join");
      }

      public join_args getEmptyArgsInstance() {
        return new join_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public join_result getResult(I iface, join_args args) throws org.apache.thrift.TException {
        join_result result = new join_result();
        iface.join(args.joiningHost, args.joiningPort);
        return result;
      }
    }

    public static class leave<I extends Iface> extends org.apache.thrift.ProcessFunction<I, leave_args> {
      public leave() {
        super("leave");
      }

      public leave_args getEmptyArgsInstance() {
        return new leave_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public leave_result getResult(I iface, leave_args args) throws org.apache.thrift.TException {
        leave_result result = new leave_result();
        iface.leave(args.leavingHost, args.leavingPort);
        return result;
      }
    }

    public static class ser<I extends Iface> extends org.apache.thrift.ProcessFunction<I, ser_args> {
      public ser() {
        super("ser");
      }

      public ser_args getEmptyArgsInstance() {
        return new ser_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public ser_result getResult(I iface, ser_args args) throws org.apache.thrift.TException {
        ser_result result = new ser_result();
        iface.ser(args.queryId, args.queryingHost, args.queryingPort, args.fileName, args.hopCount);
        return result;
      }
    }

    public static class serok<I extends Iface> extends org.apache.thrift.ProcessFunction<I, serok_args> {
      public serok() {
        super("serok");
      }

      public serok_args getEmptyArgsInstance() {
        return new serok_args();
      }

      protected boolean isOneway() {
        return false;
      }

      public serok_result getResult(I iface, serok_args args) throws org.apache.thrift.TException {
        serok_result result = new serok_result();
        iface.serok(args.queryId, args.foundHost, args.foundPort, args.matchingFiles, args.hopCount);
        return result;
      }
    }

  }

  public static class AsyncProcessor<I extends AsyncIface> extends org.apache.thrift.TBaseAsyncProcessor<I> {
    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncProcessor.class.getName());
    public AsyncProcessor(I iface) {
      super(iface, getProcessMap(new HashMap<String, org.apache.thrift.AsyncProcessFunction<I, ? extends org.apache.thrift.TBase, ?>>()));
    }

    protected AsyncProcessor(I iface, Map<String,  org.apache.thrift.AsyncProcessFunction<I, ? extends  org.apache.thrift.TBase, ?>> processMap) {
      super(iface, getProcessMap(processMap));
    }

    private static <I extends AsyncIface> Map<String,  org.apache.thrift.AsyncProcessFunction<I, ? extends  org.apache.thrift.TBase,?>> getProcessMap(Map<String,  org.apache.thrift.AsyncProcessFunction<I, ? extends  org.apache.thrift.TBase, ?>> processMap) {
      processMap.put("join", new join());
      processMap.put("leave", new leave());
      processMap.put("ser", new ser());
      processMap.put("serok", new serok());
      return processMap;
    }

    public static class join<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, join_args, Void> {
      public join() {
        super("join");
      }

      public join_args getEmptyArgsInstance() {
        return new join_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            join_result result = new join_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            join_result result = new join_result();
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, join_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.join(args.joiningHost, args.joiningPort,resultHandler);
      }
    }

    public static class leave<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, leave_args, Void> {
      public leave() {
        super("leave");
      }

      public leave_args getEmptyArgsInstance() {
        return new leave_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            leave_result result = new leave_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            leave_result result = new leave_result();
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, leave_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.leave(args.leavingHost, args.leavingPort,resultHandler);
      }
    }

    public static class ser<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, ser_args, Void> {
      public ser() {
        super("ser");
      }

      public ser_args getEmptyArgsInstance() {
        return new ser_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            ser_result result = new ser_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            ser_result result = new ser_result();
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, ser_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.ser(args.queryId, args.queryingHost, args.queryingPort, args.fileName, args.hopCount,resultHandler);
      }
    }

    public static class serok<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, serok_args, Void> {
      public serok() {
        super("serok");
      }

      public serok_args getEmptyArgsInstance() {
        return new serok_args();
      }

      public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
        final org.apache.thrift.AsyncProcessFunction fcall = this;
        return new AsyncMethodCallback<Void>() { 
          public void onComplete(Void o) {
            serok_result result = new serok_result();
            try {
              fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
              return;
            } catch (Exception e) {
              LOGGER.error("Exception writing to internal frame buffer", e);
            }
            fb.close();
          }
          public void onError(Exception e) {
            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
            org.apache.thrift.TBase msg;
            serok_result result = new serok_result();
            {
              msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
              msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
            }
            try {
              fcall.sendResponse(fb,msg,msgType,seqid);
              return;
            } catch (Exception ex) {
              LOGGER.error("Exception writing to internal frame buffer", ex);
            }
            fb.close();
          }
        };
      }

      protected boolean isOneway() {
        return false;
      }

      public void start(I iface, serok_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException {
        iface.serok(args.queryId, args.foundHost, args.foundPort, args.matchingFiles, args.hopCount,resultHandler);
      }
    }

  }

  public static class join_args implements org.apache.thrift.TBase<join_args, join_args._Fields>, java.io.Serializable, Cloneable, Comparable<join_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("join_args");

    private static final org.apache.thrift.protocol.TField JOINING_HOST_FIELD_DESC = new org.apache.thrift.protocol.TField("joiningHost", org.apache.thrift.protocol.TType.STRING, (short)1);
    private static final org.apache.thrift.protocol.TField JOINING_PORT_FIELD_DESC = new org.apache.thrift.protocol.TField("joiningPort", org.apache.thrift.protocol.TType.I32, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new join_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new join_argsTupleSchemeFactory());
    }

    public String joiningHost; // required
    public int joiningPort; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      JOINING_HOST((short)1, "joiningHost"),
      JOINING_PORT((short)2, "joiningPort");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // JOINING_HOST
            return JOINING_HOST;
          case 2: // JOINING_PORT
            return JOINING_PORT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __JOININGPORT_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.JOINING_HOST, new org.apache.thrift.meta_data.FieldMetaData("joiningHost", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.JOINING_PORT, new org.apache.thrift.meta_data.FieldMetaData("joiningPort", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(join_args.class, metaDataMap);
    }

    public join_args() {
    }

    public join_args(
      String joiningHost,
      int joiningPort)
    {
      this();
      this.joiningHost = joiningHost;
      this.joiningPort = joiningPort;
      setJoiningPortIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public join_args(join_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetJoiningHost()) {
        this.joiningHost = other.joiningHost;
      }
      this.joiningPort = other.joiningPort;
    }

    public join_args deepCopy() {
      return new join_args(this);
    }

    @Override
    public void clear() {
      this.joiningHost = null;
      setJoiningPortIsSet(false);
      this.joiningPort = 0;
    }

    public String getJoiningHost() {
      return this.joiningHost;
    }

    public join_args setJoiningHost(String joiningHost) {
      this.joiningHost = joiningHost;
      return this;
    }

    public void unsetJoiningHost() {
      this.joiningHost = null;
    }

    /** Returns true if field joiningHost is set (has been assigned a value) and false otherwise */
    public boolean isSetJoiningHost() {
      return this.joiningHost != null;
    }

    public void setJoiningHostIsSet(boolean value) {
      if (!value) {
        this.joiningHost = null;
      }
    }

    public int getJoiningPort() {
      return this.joiningPort;
    }

    public join_args setJoiningPort(int joiningPort) {
      this.joiningPort = joiningPort;
      setJoiningPortIsSet(true);
      return this;
    }

    public void unsetJoiningPort() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __JOININGPORT_ISSET_ID);
    }

    /** Returns true if field joiningPort is set (has been assigned a value) and false otherwise */
    public boolean isSetJoiningPort() {
      return EncodingUtils.testBit(__isset_bitfield, __JOININGPORT_ISSET_ID);
    }

    public void setJoiningPortIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __JOININGPORT_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case JOINING_HOST:
        if (value == null) {
          unsetJoiningHost();
        } else {
          setJoiningHost((String)value);
        }
        break;

      case JOINING_PORT:
        if (value == null) {
          unsetJoiningPort();
        } else {
          setJoiningPort((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case JOINING_HOST:
        return getJoiningHost();

      case JOINING_PORT:
        return Integer.valueOf(getJoiningPort());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case JOINING_HOST:
        return isSetJoiningHost();
      case JOINING_PORT:
        return isSetJoiningPort();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof join_args)
        return this.equals((join_args)that);
      return false;
    }

    public boolean equals(join_args that) {
      if (that == null)
        return false;

      boolean this_present_joiningHost = true && this.isSetJoiningHost();
      boolean that_present_joiningHost = true && that.isSetJoiningHost();
      if (this_present_joiningHost || that_present_joiningHost) {
        if (!(this_present_joiningHost && that_present_joiningHost))
          return false;
        if (!this.joiningHost.equals(that.joiningHost))
          return false;
      }

      boolean this_present_joiningPort = true;
      boolean that_present_joiningPort = true;
      if (this_present_joiningPort || that_present_joiningPort) {
        if (!(this_present_joiningPort && that_present_joiningPort))
          return false;
        if (this.joiningPort != that.joiningPort)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_joiningHost = true && (isSetJoiningHost());
      list.add(present_joiningHost);
      if (present_joiningHost)
        list.add(joiningHost);

      boolean present_joiningPort = true;
      list.add(present_joiningPort);
      if (present_joiningPort)
        list.add(joiningPort);

      return list.hashCode();
    }

    @Override
    public int compareTo(join_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetJoiningHost()).compareTo(other.isSetJoiningHost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetJoiningHost()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.joiningHost, other.joiningHost);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetJoiningPort()).compareTo(other.isSetJoiningPort());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetJoiningPort()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.joiningPort, other.joiningPort);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("join_args(");
      boolean first = true;

      sb.append("joiningHost:");
      if (this.joiningHost == null) {
        sb.append("null");
      } else {
        sb.append(this.joiningHost);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("joiningPort:");
      sb.append(this.joiningPort);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      if (joiningHost == null) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'joiningHost' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'joiningPort' because it's a primitive and you chose the non-beans generator.
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class join_argsStandardSchemeFactory implements SchemeFactory {
      public join_argsStandardScheme getScheme() {
        return new join_argsStandardScheme();
      }
    }

    private static class join_argsStandardScheme extends StandardScheme<join_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, join_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // JOINING_HOST
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.joiningHost = iprot.readString();
                struct.setJoiningHostIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // JOINING_PORT
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.joiningPort = iprot.readI32();
                struct.setJoiningPortIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        if (!struct.isSetJoiningPort()) {
          throw new org.apache.thrift.protocol.TProtocolException("Required field 'joiningPort' was not found in serialized data! Struct: " + toString());
        }
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, join_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.joiningHost != null) {
          oprot.writeFieldBegin(JOINING_HOST_FIELD_DESC);
          oprot.writeString(struct.joiningHost);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(JOINING_PORT_FIELD_DESC);
        oprot.writeI32(struct.joiningPort);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class join_argsTupleSchemeFactory implements SchemeFactory {
      public join_argsTupleScheme getScheme() {
        return new join_argsTupleScheme();
      }
    }

    private static class join_argsTupleScheme extends TupleScheme<join_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, join_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        oprot.writeString(struct.joiningHost);
        oprot.writeI32(struct.joiningPort);
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, join_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        struct.joiningHost = iprot.readString();
        struct.setJoiningHostIsSet(true);
        struct.joiningPort = iprot.readI32();
        struct.setJoiningPortIsSet(true);
      }
    }

  }

  public static class join_result implements org.apache.thrift.TBase<join_result, join_result._Fields>, java.io.Serializable, Cloneable, Comparable<join_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("join_result");


    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new join_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new join_resultTupleSchemeFactory());
    }


    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(join_result.class, metaDataMap);
    }

    public join_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public join_result(join_result other) {
    }

    public join_result deepCopy() {
      return new join_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof join_result)
        return this.equals((join_result)that);
      return false;
    }

    public boolean equals(join_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      return list.hashCode();
    }

    @Override
    public int compareTo(join_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("join_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class join_resultStandardSchemeFactory implements SchemeFactory {
      public join_resultStandardScheme getScheme() {
        return new join_resultStandardScheme();
      }
    }

    private static class join_resultStandardScheme extends StandardScheme<join_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, join_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, join_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class join_resultTupleSchemeFactory implements SchemeFactory {
      public join_resultTupleScheme getScheme() {
        return new join_resultTupleScheme();
      }
    }

    private static class join_resultTupleScheme extends TupleScheme<join_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, join_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, join_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
      }
    }

  }

  public static class leave_args implements org.apache.thrift.TBase<leave_args, leave_args._Fields>, java.io.Serializable, Cloneable, Comparable<leave_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("leave_args");

    private static final org.apache.thrift.protocol.TField LEAVING_HOST_FIELD_DESC = new org.apache.thrift.protocol.TField("leavingHost", org.apache.thrift.protocol.TType.STRING, (short)1);
    private static final org.apache.thrift.protocol.TField LEAVING_PORT_FIELD_DESC = new org.apache.thrift.protocol.TField("leavingPort", org.apache.thrift.protocol.TType.I32, (short)2);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new leave_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new leave_argsTupleSchemeFactory());
    }

    public String leavingHost; // required
    public int leavingPort; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      LEAVING_HOST((short)1, "leavingHost"),
      LEAVING_PORT((short)2, "leavingPort");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // LEAVING_HOST
            return LEAVING_HOST;
          case 2: // LEAVING_PORT
            return LEAVING_PORT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __LEAVINGPORT_ISSET_ID = 0;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.LEAVING_HOST, new org.apache.thrift.meta_data.FieldMetaData("leavingHost", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.LEAVING_PORT, new org.apache.thrift.meta_data.FieldMetaData("leavingPort", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(leave_args.class, metaDataMap);
    }

    public leave_args() {
    }

    public leave_args(
      String leavingHost,
      int leavingPort)
    {
      this();
      this.leavingHost = leavingHost;
      this.leavingPort = leavingPort;
      setLeavingPortIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leave_args(leave_args other) {
      __isset_bitfield = other.__isset_bitfield;
      if (other.isSetLeavingHost()) {
        this.leavingHost = other.leavingHost;
      }
      this.leavingPort = other.leavingPort;
    }

    public leave_args deepCopy() {
      return new leave_args(this);
    }

    @Override
    public void clear() {
      this.leavingHost = null;
      setLeavingPortIsSet(false);
      this.leavingPort = 0;
    }

    public String getLeavingHost() {
      return this.leavingHost;
    }

    public leave_args setLeavingHost(String leavingHost) {
      this.leavingHost = leavingHost;
      return this;
    }

    public void unsetLeavingHost() {
      this.leavingHost = null;
    }

    /** Returns true if field leavingHost is set (has been assigned a value) and false otherwise */
    public boolean isSetLeavingHost() {
      return this.leavingHost != null;
    }

    public void setLeavingHostIsSet(boolean value) {
      if (!value) {
        this.leavingHost = null;
      }
    }

    public int getLeavingPort() {
      return this.leavingPort;
    }

    public leave_args setLeavingPort(int leavingPort) {
      this.leavingPort = leavingPort;
      setLeavingPortIsSet(true);
      return this;
    }

    public void unsetLeavingPort() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __LEAVINGPORT_ISSET_ID);
    }

    /** Returns true if field leavingPort is set (has been assigned a value) and false otherwise */
    public boolean isSetLeavingPort() {
      return EncodingUtils.testBit(__isset_bitfield, __LEAVINGPORT_ISSET_ID);
    }

    public void setLeavingPortIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __LEAVINGPORT_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case LEAVING_HOST:
        if (value == null) {
          unsetLeavingHost();
        } else {
          setLeavingHost((String)value);
        }
        break;

      case LEAVING_PORT:
        if (value == null) {
          unsetLeavingPort();
        } else {
          setLeavingPort((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case LEAVING_HOST:
        return getLeavingHost();

      case LEAVING_PORT:
        return Integer.valueOf(getLeavingPort());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case LEAVING_HOST:
        return isSetLeavingHost();
      case LEAVING_PORT:
        return isSetLeavingPort();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof leave_args)
        return this.equals((leave_args)that);
      return false;
    }

    public boolean equals(leave_args that) {
      if (that == null)
        return false;

      boolean this_present_leavingHost = true && this.isSetLeavingHost();
      boolean that_present_leavingHost = true && that.isSetLeavingHost();
      if (this_present_leavingHost || that_present_leavingHost) {
        if (!(this_present_leavingHost && that_present_leavingHost))
          return false;
        if (!this.leavingHost.equals(that.leavingHost))
          return false;
      }

      boolean this_present_leavingPort = true;
      boolean that_present_leavingPort = true;
      if (this_present_leavingPort || that_present_leavingPort) {
        if (!(this_present_leavingPort && that_present_leavingPort))
          return false;
        if (this.leavingPort != that.leavingPort)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_leavingHost = true && (isSetLeavingHost());
      list.add(present_leavingHost);
      if (present_leavingHost)
        list.add(leavingHost);

      boolean present_leavingPort = true;
      list.add(present_leavingPort);
      if (present_leavingPort)
        list.add(leavingPort);

      return list.hashCode();
    }

    @Override
    public int compareTo(leave_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetLeavingHost()).compareTo(other.isSetLeavingHost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLeavingHost()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.leavingHost, other.leavingHost);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetLeavingPort()).compareTo(other.isSetLeavingPort());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLeavingPort()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.leavingPort, other.leavingPort);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("leave_args(");
      boolean first = true;

      sb.append("leavingHost:");
      if (this.leavingHost == null) {
        sb.append("null");
      } else {
        sb.append(this.leavingHost);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("leavingPort:");
      sb.append(this.leavingPort);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      if (leavingHost == null) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'leavingHost' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'leavingPort' because it's a primitive and you chose the non-beans generator.
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class leave_argsStandardSchemeFactory implements SchemeFactory {
      public leave_argsStandardScheme getScheme() {
        return new leave_argsStandardScheme();
      }
    }

    private static class leave_argsStandardScheme extends StandardScheme<leave_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, leave_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // LEAVING_HOST
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.leavingHost = iprot.readString();
                struct.setLeavingHostIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // LEAVING_PORT
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.leavingPort = iprot.readI32();
                struct.setLeavingPortIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        if (!struct.isSetLeavingPort()) {
          throw new org.apache.thrift.protocol.TProtocolException("Required field 'leavingPort' was not found in serialized data! Struct: " + toString());
        }
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, leave_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        if (struct.leavingHost != null) {
          oprot.writeFieldBegin(LEAVING_HOST_FIELD_DESC);
          oprot.writeString(struct.leavingHost);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(LEAVING_PORT_FIELD_DESC);
        oprot.writeI32(struct.leavingPort);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class leave_argsTupleSchemeFactory implements SchemeFactory {
      public leave_argsTupleScheme getScheme() {
        return new leave_argsTupleScheme();
      }
    }

    private static class leave_argsTupleScheme extends TupleScheme<leave_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, leave_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        oprot.writeString(struct.leavingHost);
        oprot.writeI32(struct.leavingPort);
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, leave_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        struct.leavingHost = iprot.readString();
        struct.setLeavingHostIsSet(true);
        struct.leavingPort = iprot.readI32();
        struct.setLeavingPortIsSet(true);
      }
    }

  }

  public static class leave_result implements org.apache.thrift.TBase<leave_result, leave_result._Fields>, java.io.Serializable, Cloneable, Comparable<leave_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("leave_result");


    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new leave_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new leave_resultTupleSchemeFactory());
    }


    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(leave_result.class, metaDataMap);
    }

    public leave_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public leave_result(leave_result other) {
    }

    public leave_result deepCopy() {
      return new leave_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof leave_result)
        return this.equals((leave_result)that);
      return false;
    }

    public boolean equals(leave_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      return list.hashCode();
    }

    @Override
    public int compareTo(leave_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("leave_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class leave_resultStandardSchemeFactory implements SchemeFactory {
      public leave_resultStandardScheme getScheme() {
        return new leave_resultStandardScheme();
      }
    }

    private static class leave_resultStandardScheme extends StandardScheme<leave_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, leave_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, leave_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class leave_resultTupleSchemeFactory implements SchemeFactory {
      public leave_resultTupleScheme getScheme() {
        return new leave_resultTupleScheme();
      }
    }

    private static class leave_resultTupleScheme extends TupleScheme<leave_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, leave_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, leave_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
      }
    }

  }

  public static class ser_args implements org.apache.thrift.TBase<ser_args, ser_args._Fields>, java.io.Serializable, Cloneable, Comparable<ser_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("ser_args");

    private static final org.apache.thrift.protocol.TField QUERY_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("queryId", org.apache.thrift.protocol.TType.I32, (short)1);
    private static final org.apache.thrift.protocol.TField QUERYING_HOST_FIELD_DESC = new org.apache.thrift.protocol.TField("queryingHost", org.apache.thrift.protocol.TType.STRING, (short)2);
    private static final org.apache.thrift.protocol.TField QUERYING_PORT_FIELD_DESC = new org.apache.thrift.protocol.TField("queryingPort", org.apache.thrift.protocol.TType.I32, (short)3);
    private static final org.apache.thrift.protocol.TField FILE_NAME_FIELD_DESC = new org.apache.thrift.protocol.TField("fileName", org.apache.thrift.protocol.TType.STRING, (short)4);
    private static final org.apache.thrift.protocol.TField HOP_COUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("hopCount", org.apache.thrift.protocol.TType.I32, (short)5);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new ser_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new ser_argsTupleSchemeFactory());
    }

    public int queryId; // required
    public String queryingHost; // required
    public int queryingPort; // required
    public String fileName; // required
    public int hopCount; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      QUERY_ID((short)1, "queryId"),
      QUERYING_HOST((short)2, "queryingHost"),
      QUERYING_PORT((short)3, "queryingPort"),
      FILE_NAME((short)4, "fileName"),
      HOP_COUNT((short)5, "hopCount");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // QUERY_ID
            return QUERY_ID;
          case 2: // QUERYING_HOST
            return QUERYING_HOST;
          case 3: // QUERYING_PORT
            return QUERYING_PORT;
          case 4: // FILE_NAME
            return FILE_NAME;
          case 5: // HOP_COUNT
            return HOP_COUNT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __QUERYID_ISSET_ID = 0;
    private static final int __QUERYINGPORT_ISSET_ID = 1;
    private static final int __HOPCOUNT_ISSET_ID = 2;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.QUERY_ID, new org.apache.thrift.meta_data.FieldMetaData("queryId", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.QUERYING_HOST, new org.apache.thrift.meta_data.FieldMetaData("queryingHost", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.QUERYING_PORT, new org.apache.thrift.meta_data.FieldMetaData("queryingPort", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.FILE_NAME, new org.apache.thrift.meta_data.FieldMetaData("fileName", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.HOP_COUNT, new org.apache.thrift.meta_data.FieldMetaData("hopCount", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(ser_args.class, metaDataMap);
    }

    public ser_args() {
    }

    public ser_args(
      int queryId,
      String queryingHost,
      int queryingPort,
      String fileName,
      int hopCount)
    {
      this();
      this.queryId = queryId;
      setQueryIdIsSet(true);
      this.queryingHost = queryingHost;
      this.queryingPort = queryingPort;
      setQueryingPortIsSet(true);
      this.fileName = fileName;
      this.hopCount = hopCount;
      setHopCountIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public ser_args(ser_args other) {
      __isset_bitfield = other.__isset_bitfield;
      this.queryId = other.queryId;
      if (other.isSetQueryingHost()) {
        this.queryingHost = other.queryingHost;
      }
      this.queryingPort = other.queryingPort;
      if (other.isSetFileName()) {
        this.fileName = other.fileName;
      }
      this.hopCount = other.hopCount;
    }

    public ser_args deepCopy() {
      return new ser_args(this);
    }

    @Override
    public void clear() {
      setQueryIdIsSet(false);
      this.queryId = 0;
      this.queryingHost = null;
      setQueryingPortIsSet(false);
      this.queryingPort = 0;
      this.fileName = null;
      setHopCountIsSet(false);
      this.hopCount = 0;
    }

    public int getQueryId() {
      return this.queryId;
    }

    public ser_args setQueryId(int queryId) {
      this.queryId = queryId;
      setQueryIdIsSet(true);
      return this;
    }

    public void unsetQueryId() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __QUERYID_ISSET_ID);
    }

    /** Returns true if field queryId is set (has been assigned a value) and false otherwise */
    public boolean isSetQueryId() {
      return EncodingUtils.testBit(__isset_bitfield, __QUERYID_ISSET_ID);
    }

    public void setQueryIdIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __QUERYID_ISSET_ID, value);
    }

    public String getQueryingHost() {
      return this.queryingHost;
    }

    public ser_args setQueryingHost(String queryingHost) {
      this.queryingHost = queryingHost;
      return this;
    }

    public void unsetQueryingHost() {
      this.queryingHost = null;
    }

    /** Returns true if field queryingHost is set (has been assigned a value) and false otherwise */
    public boolean isSetQueryingHost() {
      return this.queryingHost != null;
    }

    public void setQueryingHostIsSet(boolean value) {
      if (!value) {
        this.queryingHost = null;
      }
    }

    public int getQueryingPort() {
      return this.queryingPort;
    }

    public ser_args setQueryingPort(int queryingPort) {
      this.queryingPort = queryingPort;
      setQueryingPortIsSet(true);
      return this;
    }

    public void unsetQueryingPort() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __QUERYINGPORT_ISSET_ID);
    }

    /** Returns true if field queryingPort is set (has been assigned a value) and false otherwise */
    public boolean isSetQueryingPort() {
      return EncodingUtils.testBit(__isset_bitfield, __QUERYINGPORT_ISSET_ID);
    }

    public void setQueryingPortIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __QUERYINGPORT_ISSET_ID, value);
    }

    public String getFileName() {
      return this.fileName;
    }

    public ser_args setFileName(String fileName) {
      this.fileName = fileName;
      return this;
    }

    public void unsetFileName() {
      this.fileName = null;
    }

    /** Returns true if field fileName is set (has been assigned a value) and false otherwise */
    public boolean isSetFileName() {
      return this.fileName != null;
    }

    public void setFileNameIsSet(boolean value) {
      if (!value) {
        this.fileName = null;
      }
    }

    public int getHopCount() {
      return this.hopCount;
    }

    public ser_args setHopCount(int hopCount) {
      this.hopCount = hopCount;
      setHopCountIsSet(true);
      return this;
    }

    public void unsetHopCount() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HOPCOUNT_ISSET_ID);
    }

    /** Returns true if field hopCount is set (has been assigned a value) and false otherwise */
    public boolean isSetHopCount() {
      return EncodingUtils.testBit(__isset_bitfield, __HOPCOUNT_ISSET_ID);
    }

    public void setHopCountIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HOPCOUNT_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case QUERY_ID:
        if (value == null) {
          unsetQueryId();
        } else {
          setQueryId((Integer)value);
        }
        break;

      case QUERYING_HOST:
        if (value == null) {
          unsetQueryingHost();
        } else {
          setQueryingHost((String)value);
        }
        break;

      case QUERYING_PORT:
        if (value == null) {
          unsetQueryingPort();
        } else {
          setQueryingPort((Integer)value);
        }
        break;

      case FILE_NAME:
        if (value == null) {
          unsetFileName();
        } else {
          setFileName((String)value);
        }
        break;

      case HOP_COUNT:
        if (value == null) {
          unsetHopCount();
        } else {
          setHopCount((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case QUERY_ID:
        return Integer.valueOf(getQueryId());

      case QUERYING_HOST:
        return getQueryingHost();

      case QUERYING_PORT:
        return Integer.valueOf(getQueryingPort());

      case FILE_NAME:
        return getFileName();

      case HOP_COUNT:
        return Integer.valueOf(getHopCount());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case QUERY_ID:
        return isSetQueryId();
      case QUERYING_HOST:
        return isSetQueryingHost();
      case QUERYING_PORT:
        return isSetQueryingPort();
      case FILE_NAME:
        return isSetFileName();
      case HOP_COUNT:
        return isSetHopCount();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof ser_args)
        return this.equals((ser_args)that);
      return false;
    }

    public boolean equals(ser_args that) {
      if (that == null)
        return false;

      boolean this_present_queryId = true;
      boolean that_present_queryId = true;
      if (this_present_queryId || that_present_queryId) {
        if (!(this_present_queryId && that_present_queryId))
          return false;
        if (this.queryId != that.queryId)
          return false;
      }

      boolean this_present_queryingHost = true && this.isSetQueryingHost();
      boolean that_present_queryingHost = true && that.isSetQueryingHost();
      if (this_present_queryingHost || that_present_queryingHost) {
        if (!(this_present_queryingHost && that_present_queryingHost))
          return false;
        if (!this.queryingHost.equals(that.queryingHost))
          return false;
      }

      boolean this_present_queryingPort = true;
      boolean that_present_queryingPort = true;
      if (this_present_queryingPort || that_present_queryingPort) {
        if (!(this_present_queryingPort && that_present_queryingPort))
          return false;
        if (this.queryingPort != that.queryingPort)
          return false;
      }

      boolean this_present_fileName = true && this.isSetFileName();
      boolean that_present_fileName = true && that.isSetFileName();
      if (this_present_fileName || that_present_fileName) {
        if (!(this_present_fileName && that_present_fileName))
          return false;
        if (!this.fileName.equals(that.fileName))
          return false;
      }

      boolean this_present_hopCount = true;
      boolean that_present_hopCount = true;
      if (this_present_hopCount || that_present_hopCount) {
        if (!(this_present_hopCount && that_present_hopCount))
          return false;
        if (this.hopCount != that.hopCount)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_queryId = true;
      list.add(present_queryId);
      if (present_queryId)
        list.add(queryId);

      boolean present_queryingHost = true && (isSetQueryingHost());
      list.add(present_queryingHost);
      if (present_queryingHost)
        list.add(queryingHost);

      boolean present_queryingPort = true;
      list.add(present_queryingPort);
      if (present_queryingPort)
        list.add(queryingPort);

      boolean present_fileName = true && (isSetFileName());
      list.add(present_fileName);
      if (present_fileName)
        list.add(fileName);

      boolean present_hopCount = true;
      list.add(present_hopCount);
      if (present_hopCount)
        list.add(hopCount);

      return list.hashCode();
    }

    @Override
    public int compareTo(ser_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetQueryId()).compareTo(other.isSetQueryId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQueryId()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.queryId, other.queryId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQueryingHost()).compareTo(other.isSetQueryingHost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQueryingHost()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.queryingHost, other.queryingHost);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQueryingPort()).compareTo(other.isSetQueryingPort());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQueryingPort()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.queryingPort, other.queryingPort);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFileName()).compareTo(other.isSetFileName());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFileName()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.fileName, other.fileName);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetHopCount()).compareTo(other.isSetHopCount());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetHopCount()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hopCount, other.hopCount);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("ser_args(");
      boolean first = true;

      sb.append("queryId:");
      sb.append(this.queryId);
      first = false;
      if (!first) sb.append(", ");
      sb.append("queryingHost:");
      if (this.queryingHost == null) {
        sb.append("null");
      } else {
        sb.append(this.queryingHost);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("queryingPort:");
      sb.append(this.queryingPort);
      first = false;
      if (!first) sb.append(", ");
      sb.append("fileName:");
      if (this.fileName == null) {
        sb.append("null");
      } else {
        sb.append(this.fileName);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("hopCount:");
      sb.append(this.hopCount);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // alas, we cannot check 'queryId' because it's a primitive and you chose the non-beans generator.
      if (queryingHost == null) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'queryingHost' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'queryingPort' because it's a primitive and you chose the non-beans generator.
      if (fileName == null) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'fileName' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'hopCount' because it's a primitive and you chose the non-beans generator.
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class ser_argsStandardSchemeFactory implements SchemeFactory {
      public ser_argsStandardScheme getScheme() {
        return new ser_argsStandardScheme();
      }
    }

    private static class ser_argsStandardScheme extends StandardScheme<ser_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, ser_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // QUERY_ID
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.queryId = iprot.readI32();
                struct.setQueryIdIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // QUERYING_HOST
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.queryingHost = iprot.readString();
                struct.setQueryingHostIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 3: // QUERYING_PORT
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.queryingPort = iprot.readI32();
                struct.setQueryingPortIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 4: // FILE_NAME
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.fileName = iprot.readString();
                struct.setFileNameIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 5: // HOP_COUNT
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.hopCount = iprot.readI32();
                struct.setHopCountIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        if (!struct.isSetQueryId()) {
          throw new org.apache.thrift.protocol.TProtocolException("Required field 'queryId' was not found in serialized data! Struct: " + toString());
        }
        if (!struct.isSetQueryingPort()) {
          throw new org.apache.thrift.protocol.TProtocolException("Required field 'queryingPort' was not found in serialized data! Struct: " + toString());
        }
        if (!struct.isSetHopCount()) {
          throw new org.apache.thrift.protocol.TProtocolException("Required field 'hopCount' was not found in serialized data! Struct: " + toString());
        }
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, ser_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        oprot.writeFieldBegin(QUERY_ID_FIELD_DESC);
        oprot.writeI32(struct.queryId);
        oprot.writeFieldEnd();
        if (struct.queryingHost != null) {
          oprot.writeFieldBegin(QUERYING_HOST_FIELD_DESC);
          oprot.writeString(struct.queryingHost);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(QUERYING_PORT_FIELD_DESC);
        oprot.writeI32(struct.queryingPort);
        oprot.writeFieldEnd();
        if (struct.fileName != null) {
          oprot.writeFieldBegin(FILE_NAME_FIELD_DESC);
          oprot.writeString(struct.fileName);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(HOP_COUNT_FIELD_DESC);
        oprot.writeI32(struct.hopCount);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class ser_argsTupleSchemeFactory implements SchemeFactory {
      public ser_argsTupleScheme getScheme() {
        return new ser_argsTupleScheme();
      }
    }

    private static class ser_argsTupleScheme extends TupleScheme<ser_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, ser_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        oprot.writeI32(struct.queryId);
        oprot.writeString(struct.queryingHost);
        oprot.writeI32(struct.queryingPort);
        oprot.writeString(struct.fileName);
        oprot.writeI32(struct.hopCount);
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, ser_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        struct.queryId = iprot.readI32();
        struct.setQueryIdIsSet(true);
        struct.queryingHost = iprot.readString();
        struct.setQueryingHostIsSet(true);
        struct.queryingPort = iprot.readI32();
        struct.setQueryingPortIsSet(true);
        struct.fileName = iprot.readString();
        struct.setFileNameIsSet(true);
        struct.hopCount = iprot.readI32();
        struct.setHopCountIsSet(true);
      }
    }

  }

  public static class ser_result implements org.apache.thrift.TBase<ser_result, ser_result._Fields>, java.io.Serializable, Cloneable, Comparable<ser_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("ser_result");


    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new ser_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new ser_resultTupleSchemeFactory());
    }


    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(ser_result.class, metaDataMap);
    }

    public ser_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public ser_result(ser_result other) {
    }

    public ser_result deepCopy() {
      return new ser_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof ser_result)
        return this.equals((ser_result)that);
      return false;
    }

    public boolean equals(ser_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      return list.hashCode();
    }

    @Override
    public int compareTo(ser_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("ser_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class ser_resultStandardSchemeFactory implements SchemeFactory {
      public ser_resultStandardScheme getScheme() {
        return new ser_resultStandardScheme();
      }
    }

    private static class ser_resultStandardScheme extends StandardScheme<ser_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, ser_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, ser_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class ser_resultTupleSchemeFactory implements SchemeFactory {
      public ser_resultTupleScheme getScheme() {
        return new ser_resultTupleScheme();
      }
    }

    private static class ser_resultTupleScheme extends TupleScheme<ser_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, ser_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, ser_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
      }
    }

  }

  public static class serok_args implements org.apache.thrift.TBase<serok_args, serok_args._Fields>, java.io.Serializable, Cloneable, Comparable<serok_args>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("serok_args");

    private static final org.apache.thrift.protocol.TField QUERY_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("queryId", org.apache.thrift.protocol.TType.I32, (short)1);
    private static final org.apache.thrift.protocol.TField FOUND_HOST_FIELD_DESC = new org.apache.thrift.protocol.TField("foundHost", org.apache.thrift.protocol.TType.STRING, (short)2);
    private static final org.apache.thrift.protocol.TField FOUND_PORT_FIELD_DESC = new org.apache.thrift.protocol.TField("foundPort", org.apache.thrift.protocol.TType.I32, (short)3);
    private static final org.apache.thrift.protocol.TField MATCHING_FILES_FIELD_DESC = new org.apache.thrift.protocol.TField("matchingFiles", org.apache.thrift.protocol.TType.LIST, (short)4);
    private static final org.apache.thrift.protocol.TField HOP_COUNT_FIELD_DESC = new org.apache.thrift.protocol.TField("hopCount", org.apache.thrift.protocol.TType.I32, (short)5);

    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new serok_argsStandardSchemeFactory());
      schemes.put(TupleScheme.class, new serok_argsTupleSchemeFactory());
    }

    public int queryId; // required
    public String foundHost; // required
    public int foundPort; // required
    public List<String> matchingFiles; // required
    public int hopCount; // required

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
      QUERY_ID((short)1, "queryId"),
      FOUND_HOST((short)2, "foundHost"),
      FOUND_PORT((short)3, "foundPort"),
      MATCHING_FILES((short)4, "matchingFiles"),
      HOP_COUNT((short)5, "hopCount");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // QUERY_ID
            return QUERY_ID;
          case 2: // FOUND_HOST
            return FOUND_HOST;
          case 3: // FOUND_PORT
            return FOUND_PORT;
          case 4: // MATCHING_FILES
            return MATCHING_FILES;
          case 5: // HOP_COUNT
            return HOP_COUNT;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __QUERYID_ISSET_ID = 0;
    private static final int __FOUNDPORT_ISSET_ID = 1;
    private static final int __HOPCOUNT_ISSET_ID = 2;
    private byte __isset_bitfield = 0;
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.QUERY_ID, new org.apache.thrift.meta_data.FieldMetaData("queryId", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.FOUND_HOST, new org.apache.thrift.meta_data.FieldMetaData("foundHost", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
      tmpMap.put(_Fields.FOUND_PORT, new org.apache.thrift.meta_data.FieldMetaData("foundPort", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      tmpMap.put(_Fields.MATCHING_FILES, new org.apache.thrift.meta_data.FieldMetaData("matchingFiles", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
              new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
      tmpMap.put(_Fields.HOP_COUNT, new org.apache.thrift.meta_data.FieldMetaData("hopCount", org.apache.thrift.TFieldRequirementType.REQUIRED, 
          new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(serok_args.class, metaDataMap);
    }

    public serok_args() {
    }

    public serok_args(
      int queryId,
      String foundHost,
      int foundPort,
      List<String> matchingFiles,
      int hopCount)
    {
      this();
      this.queryId = queryId;
      setQueryIdIsSet(true);
      this.foundHost = foundHost;
      this.foundPort = foundPort;
      setFoundPortIsSet(true);
      this.matchingFiles = matchingFiles;
      this.hopCount = hopCount;
      setHopCountIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public serok_args(serok_args other) {
      __isset_bitfield = other.__isset_bitfield;
      this.queryId = other.queryId;
      if (other.isSetFoundHost()) {
        this.foundHost = other.foundHost;
      }
      this.foundPort = other.foundPort;
      if (other.isSetMatchingFiles()) {
        List<String> __this__matchingFiles = new ArrayList<String>(other.matchingFiles);
        this.matchingFiles = __this__matchingFiles;
      }
      this.hopCount = other.hopCount;
    }

    public serok_args deepCopy() {
      return new serok_args(this);
    }

    @Override
    public void clear() {
      setQueryIdIsSet(false);
      this.queryId = 0;
      this.foundHost = null;
      setFoundPortIsSet(false);
      this.foundPort = 0;
      this.matchingFiles = null;
      setHopCountIsSet(false);
      this.hopCount = 0;
    }

    public int getQueryId() {
      return this.queryId;
    }

    public serok_args setQueryId(int queryId) {
      this.queryId = queryId;
      setQueryIdIsSet(true);
      return this;
    }

    public void unsetQueryId() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __QUERYID_ISSET_ID);
    }

    /** Returns true if field queryId is set (has been assigned a value) and false otherwise */
    public boolean isSetQueryId() {
      return EncodingUtils.testBit(__isset_bitfield, __QUERYID_ISSET_ID);
    }

    public void setQueryIdIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __QUERYID_ISSET_ID, value);
    }

    public String getFoundHost() {
      return this.foundHost;
    }

    public serok_args setFoundHost(String foundHost) {
      this.foundHost = foundHost;
      return this;
    }

    public void unsetFoundHost() {
      this.foundHost = null;
    }

    /** Returns true if field foundHost is set (has been assigned a value) and false otherwise */
    public boolean isSetFoundHost() {
      return this.foundHost != null;
    }

    public void setFoundHostIsSet(boolean value) {
      if (!value) {
        this.foundHost = null;
      }
    }

    public int getFoundPort() {
      return this.foundPort;
    }

    public serok_args setFoundPort(int foundPort) {
      this.foundPort = foundPort;
      setFoundPortIsSet(true);
      return this;
    }

    public void unsetFoundPort() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __FOUNDPORT_ISSET_ID);
    }

    /** Returns true if field foundPort is set (has been assigned a value) and false otherwise */
    public boolean isSetFoundPort() {
      return EncodingUtils.testBit(__isset_bitfield, __FOUNDPORT_ISSET_ID);
    }

    public void setFoundPortIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __FOUNDPORT_ISSET_ID, value);
    }

    public int getMatchingFilesSize() {
      return (this.matchingFiles == null) ? 0 : this.matchingFiles.size();
    }

    public java.util.Iterator<String> getMatchingFilesIterator() {
      return (this.matchingFiles == null) ? null : this.matchingFiles.iterator();
    }

    public void addToMatchingFiles(String elem) {
      if (this.matchingFiles == null) {
        this.matchingFiles = new ArrayList<String>();
      }
      this.matchingFiles.add(elem);
    }

    public List<String> getMatchingFiles() {
      return this.matchingFiles;
    }

    public serok_args setMatchingFiles(List<String> matchingFiles) {
      this.matchingFiles = matchingFiles;
      return this;
    }

    public void unsetMatchingFiles() {
      this.matchingFiles = null;
    }

    /** Returns true if field matchingFiles is set (has been assigned a value) and false otherwise */
    public boolean isSetMatchingFiles() {
      return this.matchingFiles != null;
    }

    public void setMatchingFilesIsSet(boolean value) {
      if (!value) {
        this.matchingFiles = null;
      }
    }

    public int getHopCount() {
      return this.hopCount;
    }

    public serok_args setHopCount(int hopCount) {
      this.hopCount = hopCount;
      setHopCountIsSet(true);
      return this;
    }

    public void unsetHopCount() {
      __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HOPCOUNT_ISSET_ID);
    }

    /** Returns true if field hopCount is set (has been assigned a value) and false otherwise */
    public boolean isSetHopCount() {
      return EncodingUtils.testBit(__isset_bitfield, __HOPCOUNT_ISSET_ID);
    }

    public void setHopCountIsSet(boolean value) {
      __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HOPCOUNT_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case QUERY_ID:
        if (value == null) {
          unsetQueryId();
        } else {
          setQueryId((Integer)value);
        }
        break;

      case FOUND_HOST:
        if (value == null) {
          unsetFoundHost();
        } else {
          setFoundHost((String)value);
        }
        break;

      case FOUND_PORT:
        if (value == null) {
          unsetFoundPort();
        } else {
          setFoundPort((Integer)value);
        }
        break;

      case MATCHING_FILES:
        if (value == null) {
          unsetMatchingFiles();
        } else {
          setMatchingFiles((List<String>)value);
        }
        break;

      case HOP_COUNT:
        if (value == null) {
          unsetHopCount();
        } else {
          setHopCount((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case QUERY_ID:
        return Integer.valueOf(getQueryId());

      case FOUND_HOST:
        return getFoundHost();

      case FOUND_PORT:
        return Integer.valueOf(getFoundPort());

      case MATCHING_FILES:
        return getMatchingFiles();

      case HOP_COUNT:
        return Integer.valueOf(getHopCount());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case QUERY_ID:
        return isSetQueryId();
      case FOUND_HOST:
        return isSetFoundHost();
      case FOUND_PORT:
        return isSetFoundPort();
      case MATCHING_FILES:
        return isSetMatchingFiles();
      case HOP_COUNT:
        return isSetHopCount();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof serok_args)
        return this.equals((serok_args)that);
      return false;
    }

    public boolean equals(serok_args that) {
      if (that == null)
        return false;

      boolean this_present_queryId = true;
      boolean that_present_queryId = true;
      if (this_present_queryId || that_present_queryId) {
        if (!(this_present_queryId && that_present_queryId))
          return false;
        if (this.queryId != that.queryId)
          return false;
      }

      boolean this_present_foundHost = true && this.isSetFoundHost();
      boolean that_present_foundHost = true && that.isSetFoundHost();
      if (this_present_foundHost || that_present_foundHost) {
        if (!(this_present_foundHost && that_present_foundHost))
          return false;
        if (!this.foundHost.equals(that.foundHost))
          return false;
      }

      boolean this_present_foundPort = true;
      boolean that_present_foundPort = true;
      if (this_present_foundPort || that_present_foundPort) {
        if (!(this_present_foundPort && that_present_foundPort))
          return false;
        if (this.foundPort != that.foundPort)
          return false;
      }

      boolean this_present_matchingFiles = true && this.isSetMatchingFiles();
      boolean that_present_matchingFiles = true && that.isSetMatchingFiles();
      if (this_present_matchingFiles || that_present_matchingFiles) {
        if (!(this_present_matchingFiles && that_present_matchingFiles))
          return false;
        if (!this.matchingFiles.equals(that.matchingFiles))
          return false;
      }

      boolean this_present_hopCount = true;
      boolean that_present_hopCount = true;
      if (this_present_hopCount || that_present_hopCount) {
        if (!(this_present_hopCount && that_present_hopCount))
          return false;
        if (this.hopCount != that.hopCount)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      boolean present_queryId = true;
      list.add(present_queryId);
      if (present_queryId)
        list.add(queryId);

      boolean present_foundHost = true && (isSetFoundHost());
      list.add(present_foundHost);
      if (present_foundHost)
        list.add(foundHost);

      boolean present_foundPort = true;
      list.add(present_foundPort);
      if (present_foundPort)
        list.add(foundPort);

      boolean present_matchingFiles = true && (isSetMatchingFiles());
      list.add(present_matchingFiles);
      if (present_matchingFiles)
        list.add(matchingFiles);

      boolean present_hopCount = true;
      list.add(present_hopCount);
      if (present_hopCount)
        list.add(hopCount);

      return list.hashCode();
    }

    @Override
    public int compareTo(serok_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      lastComparison = Boolean.valueOf(isSetQueryId()).compareTo(other.isSetQueryId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQueryId()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.queryId, other.queryId);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFoundHost()).compareTo(other.isSetFoundHost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFoundHost()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.foundHost, other.foundHost);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetFoundPort()).compareTo(other.isSetFoundPort());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetFoundPort()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.foundPort, other.foundPort);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetMatchingFiles()).compareTo(other.isSetMatchingFiles());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetMatchingFiles()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.matchingFiles, other.matchingFiles);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetHopCount()).compareTo(other.isSetHopCount());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetHopCount()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.hopCount, other.hopCount);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("serok_args(");
      boolean first = true;

      sb.append("queryId:");
      sb.append(this.queryId);
      first = false;
      if (!first) sb.append(", ");
      sb.append("foundHost:");
      if (this.foundHost == null) {
        sb.append("null");
      } else {
        sb.append(this.foundHost);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("foundPort:");
      sb.append(this.foundPort);
      first = false;
      if (!first) sb.append(", ");
      sb.append("matchingFiles:");
      if (this.matchingFiles == null) {
        sb.append("null");
      } else {
        sb.append(this.matchingFiles);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("hopCount:");
      sb.append(this.hopCount);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // alas, we cannot check 'queryId' because it's a primitive and you chose the non-beans generator.
      if (foundHost == null) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'foundHost' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'foundPort' because it's a primitive and you chose the non-beans generator.
      if (matchingFiles == null) {
        throw new org.apache.thrift.protocol.TProtocolException("Required field 'matchingFiles' was not present! Struct: " + toString());
      }
      // alas, we cannot check 'hopCount' because it's a primitive and you chose the non-beans generator.
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
        __isset_bitfield = 0;
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class serok_argsStandardSchemeFactory implements SchemeFactory {
      public serok_argsStandardScheme getScheme() {
        return new serok_argsStandardScheme();
      }
    }

    private static class serok_argsStandardScheme extends StandardScheme<serok_args> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, serok_args struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            case 1: // QUERY_ID
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.queryId = iprot.readI32();
                struct.setQueryIdIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 2: // FOUND_HOST
              if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
                struct.foundHost = iprot.readString();
                struct.setFoundHostIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 3: // FOUND_PORT
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.foundPort = iprot.readI32();
                struct.setFoundPortIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 4: // MATCHING_FILES
              if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
                {
                  org.apache.thrift.protocol.TList _list0 = iprot.readListBegin();
                  struct.matchingFiles = new ArrayList<String>(_list0.size);
                  for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                  {
                    String _elem2;
                    _elem2 = iprot.readString();
                    struct.matchingFiles.add(_elem2);
                  }
                  iprot.readListEnd();
                }
                struct.setMatchingFilesIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            case 5: // HOP_COUNT
              if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
                struct.hopCount = iprot.readI32();
                struct.setHopCountIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
              break;
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        if (!struct.isSetQueryId()) {
          throw new org.apache.thrift.protocol.TProtocolException("Required field 'queryId' was not found in serialized data! Struct: " + toString());
        }
        if (!struct.isSetFoundPort()) {
          throw new org.apache.thrift.protocol.TProtocolException("Required field 'foundPort' was not found in serialized data! Struct: " + toString());
        }
        if (!struct.isSetHopCount()) {
          throw new org.apache.thrift.protocol.TProtocolException("Required field 'hopCount' was not found in serialized data! Struct: " + toString());
        }
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, serok_args struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        oprot.writeFieldBegin(QUERY_ID_FIELD_DESC);
        oprot.writeI32(struct.queryId);
        oprot.writeFieldEnd();
        if (struct.foundHost != null) {
          oprot.writeFieldBegin(FOUND_HOST_FIELD_DESC);
          oprot.writeString(struct.foundHost);
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(FOUND_PORT_FIELD_DESC);
        oprot.writeI32(struct.foundPort);
        oprot.writeFieldEnd();
        if (struct.matchingFiles != null) {
          oprot.writeFieldBegin(MATCHING_FILES_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, struct.matchingFiles.size()));
            for (String _iter3 : struct.matchingFiles)
            {
              oprot.writeString(_iter3);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
        oprot.writeFieldBegin(HOP_COUNT_FIELD_DESC);
        oprot.writeI32(struct.hopCount);
        oprot.writeFieldEnd();
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class serok_argsTupleSchemeFactory implements SchemeFactory {
      public serok_argsTupleScheme getScheme() {
        return new serok_argsTupleScheme();
      }
    }

    private static class serok_argsTupleScheme extends TupleScheme<serok_args> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, serok_args struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
        oprot.writeI32(struct.queryId);
        oprot.writeString(struct.foundHost);
        oprot.writeI32(struct.foundPort);
        {
          oprot.writeI32(struct.matchingFiles.size());
          for (String _iter4 : struct.matchingFiles)
          {
            oprot.writeString(_iter4);
          }
        }
        oprot.writeI32(struct.hopCount);
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, serok_args struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
        struct.queryId = iprot.readI32();
        struct.setQueryIdIsSet(true);
        struct.foundHost = iprot.readString();
        struct.setFoundHostIsSet(true);
        struct.foundPort = iprot.readI32();
        struct.setFoundPortIsSet(true);
        {
          org.apache.thrift.protocol.TList _list5 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, iprot.readI32());
          struct.matchingFiles = new ArrayList<String>(_list5.size);
          for (int _i6 = 0; _i6 < _list5.size; ++_i6)
          {
            String _elem7;
            _elem7 = iprot.readString();
            struct.matchingFiles.add(_elem7);
          }
        }
        struct.setMatchingFilesIsSet(true);
        struct.hopCount = iprot.readI32();
        struct.setHopCountIsSet(true);
      }
    }

  }

  public static class serok_result implements org.apache.thrift.TBase<serok_result, serok_result._Fields>, java.io.Serializable, Cloneable, Comparable<serok_result>   {
    private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("serok_result");


    private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
    static {
      schemes.put(StandardScheme.class, new serok_resultStandardSchemeFactory());
      schemes.put(TupleScheme.class, new serok_resultTupleSchemeFactory());
    }


    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements org.apache.thrift.TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
    static {
      Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(serok_result.class, metaDataMap);
    }

    public serok_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public serok_result(serok_result other) {
    }

    public serok_result deepCopy() {
      return new serok_result(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof serok_result)
        return this.equals((serok_result)that);
      return false;
    }

    public boolean equals(serok_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      List<Object> list = new ArrayList<Object>();

      return list.hashCode();
    }

    @Override
    public int compareTo(serok_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
      schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
      schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
      }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("serok_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws org.apache.thrift.TException {
      // check for required fields
      // check for sub-struct validity
    }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      try {
        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
      try {
        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
      } catch (org.apache.thrift.TException te) {
        throw new java.io.IOException(te);
      }
    }

    private static class serok_resultStandardSchemeFactory implements SchemeFactory {
      public serok_resultStandardScheme getScheme() {
        return new serok_resultStandardScheme();
      }
    }

    private static class serok_resultStandardScheme extends StandardScheme<serok_result> {

      public void read(org.apache.thrift.protocol.TProtocol iprot, serok_result struct) throws org.apache.thrift.TException {
        org.apache.thrift.protocol.TField schemeField;
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin();
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break;
          }
          switch (schemeField.id) {
            default:
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      public void write(org.apache.thrift.protocol.TProtocol oprot, serok_result struct) throws org.apache.thrift.TException {
        struct.validate();

        oprot.writeStructBegin(STRUCT_DESC);
        oprot.writeFieldStop();
        oprot.writeStructEnd();
      }

    }

    private static class serok_resultTupleSchemeFactory implements SchemeFactory {
      public serok_resultTupleScheme getScheme() {
        return new serok_resultTupleScheme();
      }
    }

    private static class serok_resultTupleScheme extends TupleScheme<serok_result> {

      @Override
      public void write(org.apache.thrift.protocol.TProtocol prot, serok_result struct) throws org.apache.thrift.TException {
        TTupleProtocol oprot = (TTupleProtocol) prot;
      }

      @Override
      public void read(org.apache.thrift.protocol.TProtocol prot, serok_result struct) throws org.apache.thrift.TException {
        TTupleProtocol iprot = (TTupleProtocol) prot;
      }
    }

  }

}
